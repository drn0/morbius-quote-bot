"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hesperus = void 0;
const discord_js_1 = require("discord.js");
const rest_1 = require("@discordjs/rest");
const v10_1 = require("discord-api-types/v10");
const path_1 = require("path");
const fs_1 = require("fs");
/**
 * Place, where Hesperus starts.
 * @see https://hesperus.js.org/
 */
class Hesperus {
    /**
     * @param {Client} client Instance of Client to listen events on.
     * @param {HesperusOptions} options Handler's options.
     */
    constructor(client, options) {
        this.client = client;
        this.options = options;
        /** Array of JSON objects, containing information about commands. */
        this.commands = [];
        /** Command files from commands directory. */
        this.commandFiles = [];
        /** Collection of commands with instances for handling. */
        this.clientCommands = new discord_js_1.Collection();
        if (!this.options.commandsFolder)
            this.options.commandsFolder = 'commands/';
        if (!this.options.eventsFolder)
            this.options.eventsFolder = 'events/';
        if (!this.options.errorMessages)
            this.options.errorMessages = {};
        if (!this.options.errorMessages.reply) {
            this.options.errorMessages.reply = true;
        }
        if (!this.options.errorMessages.onlyOwner) {
            this.options.errorMessages.onlyOwner =
                'This command can be only used by bot owner!';
        }
        if (!this.options.extensions)
            this.options.extensions = ['.js', '.ts'];
        this.commandsPath = (0, path_1.join)(this.options.rootDir, this.options.commandsFolder);
        if (!(0, fs_1.existsSync)(this.commandsPath))
            (0, fs_1.mkdirSync)(this.commandsPath);
        this.options.extensions.forEach((extension) => {
            (0, fs_1.readdirSync)(this.commandsPath).forEach((file) => {
                if (file.endsWith(extension))
                    this.commandFiles.push(file);
            });
        });
        this.loadCommandsFromFiles();
        this.client.on('ready', async () => {
            this.deployCommands().then(() => {
            });
        });
        const eventsPath = (0, path_1.join)(this.options.rootDir, this.options.eventsFolder);
        if (!(0, fs_1.existsSync)(eventsPath))
            (0, fs_1.mkdirSync)(eventsPath);
        const eventFiles = (0, fs_1.readdirSync)(eventsPath);
        eventFiles.forEach(async (file) => {
            const eventFile = require((0, path_1.join)(eventsPath, file));
            const event = eventFile.default ? eventFile.default : eventFile;
            if (event.once) {
                client.once(event.name, async (...args) => await event.callback(...args));
            }
            else {
                client.on(event.name, async (...args) => await event.callback(...args));
            }
        });
        this.client.on('interactionCreate', async (interaction) => {
            if (!interaction.isCommand())
                return;
            const command = this.clientCommands.get(interaction.commandName);
            if (!command)
                return;
            const cmd = command;
            if (cmd.subCommandGroupsCollection.size > 0) {
                const subCommandGroup = interaction.options.getSubcommandGroup();
                const group = cmd.subCommandGroupsCollection.get(subCommandGroup);
                const commands = group.commands;
                for (const command of commands) {
                    if (command.name === interaction.options.getSubcommand()) {
                        if (await this.isCommandOwnerOnly(command.onlyOwners, interaction)) {
                            await command.callback(this.client, interaction);
                            break;
                        }
                        break;
                    }
                }
            }
            else if (cmd.subCommandsCollection.size > 0) {
                const subCommand = interaction.options.getSubcommand();
                const handler = cmd.subCommandsCollection.get(subCommand);
                if (handler) {
                    if (await this.isCommandOwnerOnly(handler.onlyOwners, interaction)) {
                        await handler.callback(this.client, interaction);
                    }
                }
            }
            else {
                if (await this.isCommandOwnerOnly(cmd.onlyOwners, interaction)) {
                    await cmd.callback(this.client, interaction);
                }
            }
        });
    }
    /**
     * This method allows you to deploy all slash commands of the bot.
     */
    async deployCommands() {
        const rest = new rest_1.REST({ version: '10' }).setToken(this.client.token);
        if (!this.options.guildIds) {
            await this.deployGlobalCommands(rest, this.commands);
        }
        else {
            for (const guildId of this.options.guildIds) {
                await this.deployGuildCommands(rest, guildId, this.commands);
            }
        }
    }
    /**
     * Method for checking and sending message if command is owner-only,
     * but user isn't an owner.
     *
     * @param {boolean} onlyOwners Whether this command is owner-only.
     * @param {CommandInteraction} interaction Interaction to reply to.
     * @private
     * @ignore
     */
    async isCommandOwnerOnly(onlyOwners, interaction) {
        if (onlyOwners && !this.options.botOwners.includes(interaction.user.id)) {
            if (this.options.errorMessages.reply) {
                await interaction.reply(this.options.errorMessages.onlyOwner);
            }
            else {
                await interaction.channel.send(this.options.errorMessages.onlyOwner);
            }
            return false;
        }
        return true;
    }
    /**
     * This method allows you to deploy the global slash commands of the bot.
     *
     * @param {REST} rest REST manager for publishing commands
     * @param {JSON[]} commands An array of commands to deploy.
     */
    async deployGlobalCommands(rest, commands) {
        await rest.put(v10_1.Routes.applicationCommands(this.client.user.id), { body: commands });
    }
    /**
     * This method allows you to deploy the guild slash commands of the bot.
     *
     * @param {REST} rest REST manager for publishing commands
     * @param {string} guildId ID of the Guild to publish commands to.
     * @param {JSON[]} commands An array of commands to deploy.
     */
    async deployGuildCommands(rest, guildId, commands) {
        await rest.put(v10_1.Routes.applicationGuildCommands(this.client.user.id, guildId), { body: commands });
    }
    /**
     * This method loads commands from files into JSON array.
     */
    loadCommandsFromFiles() {
        for (const file of this.commandFiles) {
            const commandFile = require((0, path_1.join)(this.commandsPath, file));
            const command = commandFile.default ? commandFile.default : commandFile;
            this.commands.push(command.toJSON());
            this.clientCommands.set(command.name, command);
        }
    }
}
exports.Hesperus = Hesperus;
